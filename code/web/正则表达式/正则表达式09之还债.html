<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            1.两种创建正则表达式的区别
            2.exec()方法
            3.()的第二个意义，单独捕获
            4.全局标识符 g

        1.exec()捕获
         => 语法：正则.exec(字符串)
         => 作业：从 字符串中 把满足正则条件的部分获取出来
         => 返回值:
            -> 原始字符串中没有符合正则要求的字符串片段
             + null
            -> 原始字符串中有符合正则要求的片段
             + 正则没有()也没有 全局标识符 g
                + 返回值是一个数组
                + 索引 0 是从字符串中捕获出来的满足正则条件的第一个内容
                + 注意：不管捕获多少次，每次都是从原来字符串的索引 0 开始检索
             + 正则有个全局标识符 g
                + 返回值是一个数组
                + 注意：第二次捕获是从第一次的结束位置开始向后查询，直到最后捕获不到为止，再下一次的时候，又从字符串的 索引0 开始检索
             + 有()
                + 返回的是一个数组
                + 索引 0 是从字符串中捕获出来的满足正则条件的第一个内容
                + 从索引 1 开始，依次是每一个小括号的单独内容
                + 注意：按照小括号的开始标志，来数是第几个小括号
            
    扩展：
        + （）有两个意义
         => 一个整体
         => 单独捕获
            + 如果你只想使用一个意义，整体的所用，不想在捕获的时候单独捕获出来
                => 你可以写出(?:)
                => 匹配但不捕获
        */

        // 1-1.没有符合要求的片段
        // var reg = /\d{3}/
        // console.log(reg.exec('asdfwsafewg'))

        // 1-2.有符合要求的片段

        //1-2-1.没有 () 没有 g
        // var reg = /^(\d{3})(\d{2})$/
        // console.log(reg.exec('ada123dsa12f'))

        //1-2-2.有全局标识符 g
        // var reg = /\d{3}/g
        // var str = 'asdsd123vce456dfgh789'
        // console.log(reg.exec(str))
        // console.log(reg.exec(str))
        // console.log(reg.exec(str))
        // console.log(reg.exec(str))

        //1-2-3.有（）
        //18 位身份证号码
        // var reg = /(\d{2})(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})(\d{2})(\d)(\d|x)/
        // var str = '我的身份证:36232220010101661x'
        // console.log(reg.exec(str))

        /*
            两种创建正则表达式的区别

            1.语法不一样
            2.书写标识符的时候
             => 字面量方式直接书写在正则的后面
             => 内置构造函数，以第二个参数的方式传递
            3.拼接字符串
             => 字面量方式不接受拼接字符串
            4.基本元字符书写
             => 字面量方式的时候，直接书写 \w,\d,\s
             => 内置构造函数书写的时候，需要书写\\w,\\d,\\s
        */

        //2-2.书写标识符
        // var reg1 = /abcd/ig
        // var reg2 = new RegExp('abcd','ig')
        // console.log(reg1)
        // console.log(reg2)

        //2-3.拼接字符串
        // var s1 = 'HH'
        // var s2 = 'MM'
        // 不能解析变量
        // var reg = /(HH|MM)/
        // console.log(reg)
        // 因为第一个参数就是要你以 字符串 的形式传递
        // 所以可以拼接字符串
        // var reg2 = new RegExp('('+s1+'|'+s2+')')
        // console.log(reg2)

        /*
            为什么内置构造函数需要书写双斜线
             + 字符串
              => 被引号包裹的所有内容叫做字符串
              => 当你在字符串里书写 斜线（\）的时候，是表示转义字符
              => 会把紧挨着他的一个内容转换
               -> 如果是有意义的内容会转换成没有意义的内容
               -> 如果是没有意义的内容会转换成有意义的内容
               -> 例子：n 是一个没有意义的内容
                + 当 n 和 转义符 在一起时，就表示 换行
             + new RegExp()
              => 第一个参数需要一个字符串
              => 你写的字符串就是正则内部的内容
              => 如果你想要得到 /\s\w\d/
              => 那么你就要给他的字符串里面写上 \s\w\d
              => 但是，因为在字符串中 \ 是转义符
              => 当你书写字符串 '\s' 的时候，\ 就会把 s 转换成有意义的特殊内容
                -> 字符串中确实没有 \s 组成的特殊意义字符，所以就变成了一个 单独的 字母 s 
             + 解决问题：
              => 使用 \ 把有意义的特殊字符 \ 转换成没有意义的文本 \
        */
            //小明说："小红早上告诉我：'今天迟到了'。"
            var str = "小明说：\"小红早上告诉我：'今天迟到了'。\""
            console.log(str)

            console.log('\w\s\d')  //其实这个字符串就是 \w\s\d
            

    </script>
</body>
</html>